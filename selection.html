<!DOCTYPE html>
<html>
<head>
<title>Simplified sphere selector</title>
    <!--
        This page represents the simplest possible use case for 
        a selection, with only a small handfull of items and no
        pagination. This is just to get out mapping on spheres and
        play around with GL renderers.
    -->
	<link rel="stylesheet" href="simple.css" /> 
	<script src="three.js"></script>
	<script src="RequestAnimationFrame.js"></script>
	<script>

    // a few constants to configure 
    const spheresegments = 32;
    const spheresize = 0.2;
	
	var renderer = null, 
		scene = null, 
		camera = null,
		animating = true;
	
	function onLoad()
	{
        var container = document.getElementById("container");
	    renderer = new THREE.WebGLRenderer( { antialias: true } );
	    renderer.setSize(container.offsetWidth, container.offsetHeight);        
	    container.appendChild( renderer.domElement );

	    // three.js scene
        scene = new THREE.Scene();
	    
        // for now, we want our background to match the web page (default is black)
        scene.background = new THREE.Color( 0xffffff );
        
        // Put in a camera
        camera = new THREE.PerspectiveCamera( 45, container.offsetWidth / container.offsetHeight, 1, 4000 );
        camera.position.set( 0, 0, 3 );
        
        // Create a directional light to show off the object
		var light = new THREE.DirectionalLight( 0xffffff, 1.5);
		light.position.set(-1, 1, 2);
		scene.add( light );

        // First, create the texture maps
        var map1Url = "360sample1_thumb.jpg",
            map2Url = "360sample2_thumb.jpg",
            map3Url = "360sample3_thumb.jpg",
            map4Url = "360sample4_thumb.jpg",
            map5Url = "360sample5_thumb.jpg";

        // load the texture images onto the maps
        var map1 = THREE.ImageUtils.loadTexture(map1Url),
            map2 = THREE.ImageUtils.loadTexture(map2Url),
            map3 = THREE.ImageUtils.loadTexture(map3Url),
            map4 = THREE.ImageUtils.loadTexture(map4Url),
            map5 = THREE.ImageUtils.loadTexture(map5Url);

        // Material to show shading; pass in each map
        // Need to experiment with different material types
        // MeshPhongMaterial is simple and fast, but all the cool
        // kids are using MeshStandardMaterial and MeshPhysicalMaterial
        var material1 = new THREE.MeshPhongMaterial({ map: map1 }),
            material2 = new THREE.MeshPhongMaterial({ map: map2 }),
            material3 = new THREE.MeshPhongMaterial({ map: map3 }),
            material4 = new THREE.MeshPhongMaterial({ map: map4 }),
            material5 = new THREE.MeshPhongMaterial({ map: map5 });

        // Create sphere , which we can re-use across our meshes
        var sphereGeometry = new THREE.SphereGeometry(spheresize, spheresegments, spheresegments);

        // Put the geometry and material together into a mesh. Note that positions
        // will be dynamically defined in a future iteration. for now, they are
        // just being set explicitly. We'll add each mesh to the scene.        
        sphere1 = new THREE.Mesh(sphereGeometry, material1);
        sphere1.position.set(-1,0,0);
        scene.add( sphere1 );
        
        sphere2 = new THREE.Mesh(sphereGeometry, material2); 
        sphere2.position.set(-0.5,0,0);
        scene.add( sphere2 );

        sphere3 = new THREE.Mesh(sphereGeometry, material3); 
        sphere3.position.set(0,0,0);
        scene.add( sphere3 );

        sphere4 = new THREE.Mesh(sphereGeometry, material4); 
        sphere4.position.set(0.5,0,0);
        scene.add( sphere4 );

        sphere5 = new THREE.Mesh(sphereGeometry, material5);
        sphere5.position.set(1,0,0);
        scene.add( sphere5 );

        // Add a mouse up handler to select a sphere
        addMouseHandler();
        // Run our render loop
        run();
	}
	function run()
	{
		// Render the scene
		renderer.render( scene, camera );
		// Spin the cube for next frame
		if (animating)
		{
            // for now, all are animating all the time
            // may make it so only mouseover sphere is rotating
			sphere1.rotation.y -= 0.002;
            sphere2.rotation.y -= 0.002;
            sphere3.rotation.y -= 0.002;
            sphere4.rotation.y -= 0.002;
            sphere5.rotation.y -= 0.002;
		}
			
		// Ask for another frame
    	requestAnimationFrame(run);	
	}
	function addMouseHandler()
	{
		var dom = renderer.domElement;
		
		dom.addEventListener( 'mouseup', onMouseUp, false);
	}
	
	function onMouseUp	(event)
	{
	    event.preventDefault();
	    animating = !animating;

        window.location.assign("viewer.html");
	}	
	
	</script>

</head>
<body onLoad="onLoad();" style="">
	<center><h1>Testing textured spheres</h1></center>
    <div id="container" style="width:95%; height:80%; position:absolute; background-color: white;"></div>
	<div id="prompt" style="width:95%; height:6%; bottom:0; text-align:center; position:absolute;">Click to view the photosphere</div>

</body>
</html>