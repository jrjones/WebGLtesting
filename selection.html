<!DOCTYPE html>
<html>
<head>
<title>Simplified sphere selector</title>
    <!--
        This page represents the simplest possible use case for 
        a selection, with only a small handfull of items and no
        pagination. This is just to get out mapping on spheres and
        play around with GL renderers.
    -->
	<link rel="stylesheet" href="./css/simple.css" /> 
	<script src="./libs/three.js"></script>
	<script src="./libs/RequestAnimationFrame.js"></script>
    <script src="./sim/sim.js"></script>
    <script src="./scripts/photosphere.js"></script>
	<script>

    // a few constants to configure 
    const spheresegments = 16;
    const spheresize = 0.15;
	
	var renderer = null, 
		scene = null, 
		camera = null,
		animating = true;


    var spheres = new Array();
    var tLoader = new THREE.TextureLoader();
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    var INTERSECTED = null;
    var selectedColor = new THREE.Color(0xff0000);
    var unselectedColor = new THREE.Color(0xffffff);

    var textHint = "none";
    var selectedSphere = null;

    // creates a photosphere of the specified size and geometric complexity textured with the specified image
    function createPhotoSphere(imageUrl, size, segments)
    {
        var myMap = tLoader.load(imageUrl);
        var myMat = new THREE.MeshPhongMaterial({map: myMap});
        var myGeometry = new THREE.SphereGeometry(size, segments, segments);
        mySphere = new THREE.Mesh(myGeometry, myMat);

        return mySphere;
    }

    // TODO: need to get out of the onLoad ickiness and move into a jquery ready
	function onLoad()
	{
        var container = document.getElementById("container");
	    renderer = new THREE.WebGLRenderer( { antialias: true } );
	    renderer.setSize(container.offsetWidth, container.offsetHeight);        
	    container.appendChild( renderer.domElement );
        
        // null values causing issues, so setting initial values which will be overwritten on first mouse move.
        mouse.x = 10;
        mouse.y = 10;

	    // three.js scene
        scene = new THREE.Scene();
	    
        // for now, we want our background to match the web page (default is black)
        scene.background = new THREE.Color( 0xffffff );
        
        // Put in a camera
        camera = new THREE.PerspectiveCamera( 45, container.offsetWidth / container.offsetHeight, 1, 4000 );
        camera.position.set( 0, 0, 3 );
        
        // Create a directional light to show off the object
		var light = new THREE.DirectionalLight( 0xffffff, 1.5);
		light.position.set(-1, 1, 2);
		scene.add( light );

        // drop in our spheres. Loop starts at 1 instead of zero for numbering simplicity since the
        // texture maps are 1-5 
        var sphereLoc = -2.2;
        for (i = 1; i < 11; i++)
        {
            // url scheme is hard-coded. Using smaller thumbnail images.
            var thumbUrl = "./images/photospheres/360sample" + i + "_thumb.jpg";
            var imageUrl = "./images/photospheres/360sample" + i;

            var sphere = new PhotoSphere(thumbUrl, imageUrl, spheresize, spheresegments);

            // how we determine the location is TBD... for now, just putting it at an offset from the last one
            var newloc = sphereLoc + (i*0.4);
            sphere.mesh.position.set(newloc,0,0);

            // Add this sphere to the array
            spheres.push(sphere);
            scene.add(spheres[i-1].mesh);
        }

        document.addEventListener( 'mousemove', onDocumentMouseMove, false);

        // Add a mouse up handler to select a sphere
        addMouseHandler();
        // Run our render loop
        run();
	}
	function run()
	{
		// Render the scene
		renderer.render( scene, camera );
		// Spin the cube for next frame
		if (animating)
		{
            // for now, all are animating all the time
            // may make it so only mouseover sphere is rotating
            spheres.forEach(function(s)
            {
                s.mesh.rotation.y -= 0.002;
            });
		}
        findIntersects();

		// Ask for another frame
    	requestAnimationFrame(run);	
	}

	function addMouseHandler()
	{
		var dom = renderer.domElement;
		
		dom.addEventListener( 'mouseup', onMouseUp, false);
	}
	
	function onMouseUp	(event)
	{
        var goUrl = null;
	    event.preventDefault();
//        console.log(selectedSphere.object.material.map.image.currentSrc);
        if (selectedSphere != null)
        {
            animating = !animating;

            // determine which sphere. Lame, but I don't know how else to do it.
            spheres.forEach(function(s)
            {
//                console.log(s.mesh.material.map.image.currentSrc);
//                console.log(selectedSphere);

                if (selectedSphere.object.material.map.image.currentSrc == s.mesh.material.map.image.currentSrc){
                    goUrl = s.imageUrl;
                    console.log(s.imageUrl);
                }
//                else{ console.log(s.mesh.material.map.image.currentSrc);}

            });
           //window.location.assign("viewer.html?" + goUrl);
            document.getElementById('myFrame').src = "./viewer.html?" + goUrl;
        }
	}	
	
    function onDocumentMouseMove( event ) {
	// calculate mouse position in normalized device coordinates
	// (-1 to +1) for both components
    event.preventDefault();
    mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
    mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;
	}

    function findIntersects(){
        // find intersections
        raycaster.setFromCamera( mouse, camera );
        var intersects = raycaster.intersectObjects( scene.children );

        for ( var i = 0; i < intersects.length; i++ ) {
            intersects[ i ].object.material.color.set( selectedColor); 
        }

        if ( intersects.length )
        {
            selectedSphere = intersects[0];
        }
        else
        {
            spheres.forEach(function(s)
            {
                s.mesh.material.color.set(unselectedColor);
            });
            selectedSphere = null;
        }

    }

	</script>

</head>
<body onLoad="onLoad();" style="">
    <div id="container" style="width:95%; height:70%; position:absolute; background-color: white;"></div>
    <iframe id="myFrame" width="80%" height="50%" style="position: absolute; top: 400px;"></iframe>
</body>
</html>