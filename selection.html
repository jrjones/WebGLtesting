<!DOCTYPE html>
<html>
<head>
<title>Simplified sphere selector</title>
    <!--
        This page represents the simplest possible use case for 
        a selection, with only a small handfull of items and no
        pagination. This is just to get out mapping on spheres and
        play around with GL renderers.
    -->
	<link rel="stylesheet" href="./css/simple.css" /> 
	<script src="./libs/three.js"></script>
	<script src="./libs/RequestAnimationFrame.js"></script>
	<script>

    // a few constants to configure 
    const spheresegments = 16;
    const spheresize = 0.15;
	
	var renderer = null, 
		scene = null, 
		camera = null,
		animating = true;


    var spheres = new Array();
    var tLoader = new THREE.TextureLoader();
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(), INTERSECTED = null;
    var textHint = "none";

    // creates a photosphere of the specified size and geometric complexity textured with the specified image
    function createPhotoSphere(imageUrl, size, segments)
    {
        var myMap = tLoader.load(imageUrl);
        var myMat = new THREE.MeshPhongMaterial({map: myMap});
        var myGeometry = new THREE.SphereGeometry(size, segments, segments);
        mySphere = new THREE.Mesh(myGeometry, myMat);

        return mySphere;
    }

    // TODO: need to get out of the onLoad ickiness and move into a jquery ready
	function onLoad()
	{
        var container = document.getElementById("container");
	    renderer = new THREE.WebGLRenderer( { antialias: true } );
	    renderer.setSize(container.offsetWidth, container.offsetHeight);        
	    container.appendChild( renderer.domElement );
        
	    // three.js scene
        scene = new THREE.Scene();
	    
        // for now, we want our background to match the web page (default is black)
        scene.background = new THREE.Color( 0xffffff );
        
        // Put in a camera
        camera = new THREE.PerspectiveCamera( 45, container.offsetWidth / container.offsetHeight, 1, 4000 );
        camera.position.set( 0, 0, 3 );
        
        // Create a directional light to show off the object
		var light = new THREE.DirectionalLight( 0xffffff, 1.5);
		light.position.set(-1, 1, 2);
		scene.add( light );

        // drop in our spheres. Loop starts at 1 instead of zero for numbering simplicity since the
        // texture maps are 1-5 
        var sphereLoc = -1.5;
        for (i = 1; i < 6; i++)
        {
            // url scheme is hard-coded. Using smaller thumbnail images.
            var url = "./images/photospheres/360sample" + i + "_thumb.jpg";
        
            var sphere = createPhotoSphere(url, spheresize, spheresegments);

            // how we determine the location is TBD... for now, just putting it at an offset from the last one
            var newloc = sphereLoc + (i*0.4);
            sphere.position.set(newloc,0,0);

            // Add this sphere to the array
            spheres.push(sphere);
            scene.add(spheres[i-1]);
            console.log(url);
        }

        document.addEventListener( 'mousemove', onDocumentMouseMove, false);

        // Add a mouse up handler to select a sphere
        addMouseHandler();
        // Run our render loop
        run();
	}
	function run()
	{
		// Render the scene
		renderer.render( scene, camera );
		// Spin the cube for next frame
		if (animating)
		{
            // for now, all are animating all the time
            // may make it so only mouseover sphere is rotating
            spheres.forEach(function(s)
            {
                s.rotation.y -= 0.002;
            });
		}

        // find intersections
        // TODO: Need to figure out why i'm off by a few pixels-- likely related to perspectiveamera settings
        raycaster.setFromCamera( mouse, camera );
        var intersects = raycaster.intersectObjects(scene.children);
  
        for ( var i = 0; i < intersects.length; i++ ) {

            intersects[ i ].object.material.color.set( 0xff0000 );

        }
		// Ask for another frame
    	requestAnimationFrame(run);	
	}

	function addMouseHandler()
	{
		var dom = renderer.domElement;
		
		dom.addEventListener( 'mouseup', onMouseUp, false);
	}
	
	function onMouseUp	(event)
	{
	    event.preventDefault();
	    animating = !animating;

        window.location.assign("viewer.html");
	}	
	
    function onDocumentMouseMove( event ) {
	// calculate mouse position in normalized device coordinates
	// (-1 to +1) for both components

	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    document.getElementById("hint").innerText = textHint;
	}

	</script>

</head>
<body onLoad="onLoad();" style="">
	<center><h1>Testing textured spheres</h1></center>
    <div id="container" style="width:95%; height:80%; position:absolute; background-color: white;"></div>
	<div id="prompt" style="width:95%; height:6%; bottom:0; text-align:center; position:absolute;">Click to view the photosphere</div>
	<div id="hint" style="width:95%; height:6%; bottom:1; text-align:center; position:absolute;">foobar</div>
</body>
</html>